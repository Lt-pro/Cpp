# 进程与线程

## 一、多进程与多线程

程序以文件形式存储在计算机中，正在运行的程序就是一个进程；CPU需要执行多个程序，为充分利用CPU资源便产生了多进程与多线程。

### 进程与线程

- 进程：运行中的程序，操作系统分配资源的最小单位；
- 线程：程序执行的最小单位，操作系统进行调度的最小单位。

每一个进程独占一部分资源；线程归属于某个进程，多个线程共享归属进程的资源。每一个进程有一个主线程。

### 并发与并行

- 并发：单核CPU执行多任务时，将CPU分为若干时间片，轮流分配给每个任务。每个时间片很短(10-20ms)，看上去像是多个任务同时执行；
- 并行：多核CPU执行多任务时，可以为每个任务指定一个核心，真正的同时执行多个任务。

多线程是并发与并行同时存在。

### 进程的生命周期

创建——就绪——运行——阻塞——结束

### PCB、进程与线程的上下文切换

- PCB：操作系统中进程的唯一标识，包含进程的标识，占据的资源；
- 进程上下文切换：当一个进程切换到另一个进程时需要保存当前进程的程序计数器、寄存器状态、栈、缓存、虚拟地址空间、IO口和文件资源等，并载入要执行的进程的相关信息，该过程称为进程上下文切换；
- 线程上下文切换：线程切换开销较小，只需切换程序计数器、寄存器状态和栈信息即可。

### 进程与线程的比较

资源占用、程序执行、切换开销

### 多线程的意义


## 二、进程调度算法


## 三、锁

### 线程安全问题

多线程中一个线程对共享变量的访问可能导致数据混乱、错误或丢失。例两个线程修改共享变量：

修改操作分为
1. 从内存读取操作数
2. 修改操作数
3. 写回操作数

当线程A执行完1-2后进入休眠，线程B执行1-2-3后进入休眠，线程A再执行3，此时线程B的操作结果被覆盖，引发线程安全问题。
线程安全问题的实质是对共享变量的操作不是原子的。

### 悲观锁与乐观锁

- 悲观锁：悲观锁假设每次访问变量都会修改值，访问时让一个线程独占共享变量，其它线程访问时进入阻塞状态直到当前线程完成操作释放资源。
- 乐观锁：乐观锁假设每次访问变量很少修改值，乐观锁不加锁也不等待，在提交修改时验证资源是否被其它线程修改了。

悲观锁适用于多写、竞争激烈的场景，它的开销是固定的；乐观锁适用于多读、竞争较少的场景，存在频繁失败和重试的开销。

### 乐观锁实现

- 版本号机制：为变量增加一个版本号字段，每次变量被修改时取值加一。线程读取变量时会一起读取版本号，写回时若版本号一致则更新，否则重试更新操作。
- CAS算法：
  - CAS算法涉及待更新值V、预期值E和新值N三个操作数；
  - 当且仅当V与E相等，CAS算法通过原子操作将V更新为N；若不等则放弃当前更新。
  - Java的原子操作是依赖于CPU的一条原子指令实现的。

### 乐观锁的问题

ABA问题：某个线程读取变量时值为A，修改时值仍为A，但可能有其它线程将其先改为B，再修改为A。
ABA问题的关键在于值比较不能保证变量没有被修改过，解决思路有加上版本号或时间戳。

CAS会使用自选操作进行重试，若长时间不成功会存在非常大的时间开销。

CAS只保证单个共享变量操作的原子性。多变量时可以实现AtomicReference类保证引用的原子性。