# 内存管理

## 一、基本介绍

内存管理负责管理操作计算机系统中的内存资源；确保所有程序可以使用内存资源，不同程序之间不会发生内存冲突以及避免内存泄漏问题

### 主要功能

- 内存分配与回收：为进程运行分配所需的存储资源并在进程生命周期结束后回收所占用的资源
- 地址转换：将进程使用的虚拟地址转换成物理地址
- 内存扩充：当实际物理内存不足时，使用虚拟内存技术或自动覆盖技术从逻辑上扩充内存
- 内存映射：将文件直接映射到进程的进程空间中，使得进程可以使用内存指针通过读写内存的方法存取文件内容，加快访问速度
- 内存优化：调整系统的内存分配与回收策略
- 内存安全：确保进程间互不干扰，避免恶意程序通过修改内存破坏系统安全性

### 内存碎片

- 原因：内存的申请和释放产生的
- 内部内存碎片：指已分配给进程但未被使用的内存块。操作系统并非分配给进程正好所需的内存大小，有的系统按2的幂次方分配内存，当进程申请65KB内存时系统会分配给进程128KB内存，导致63KB的内存碎片。
- 外部内存碎片：指未分配且大小太小无法给任何进程使用的内存块。

### 连续内存管理方式

- 连续内存管理：一个进程使用一块连续的存储空间
- 块式管理：将内存分为几个固定大小的块，当有进程需要内存时就分配一个块。会产生严重的内部内存碎片和外部内存碎片
- 伙伴系统：Linux中连续内存管理的方式，分配时先找到一个大小合适的内存块，如果过大就将其分为两个大小相等的伙伴块，直到不能再分割为止；当相邻的伙伴块都被释放时，系统将其合并为一个内存块。伙伴系统可以有效解决外部内存碎片问题，但由于按2的幂次方分配内存，还是会有内部内存碎片问题

### 非连续内存管理

- 非连续内存管理：一个进程可以使用不相邻的存储空间
- 分段管理：按段的形式管理和分配内存。进程的的虚拟地址空间被分配为大小不等的段，每个段具有实际意义，如主程序段MAIN，子程序段X，数据段D及栈段S等
- 分页管理：物理内存和虚拟地址空间分为连续等长的物理页和虚拟页，现代操作系统广泛使用的内存管理方式
- 段页式管理机制：先将物理内存分为若干段，每个段又继续分为若干大小相等的页

## 二、虚拟内存

### 虚拟内存的概念和主要作用

虚拟内存(Virtual Memory)是计算机系统进行内存管理非常重要的一个技术。虚拟内存是逻辑上存在的内存空间，主要作用是作为进程访问主存的桥梁并简化内存管理。

主要功能：

- 隔离进程：物理内存通过虚拟内存访问，进程与虚拟内存空间一一对应。每个进程认为占据整个物理内存，进程间彼此隔离，一个进程无法访问或更改另一个进程或操作系统使用的内存空间。
- 提升物理内存利用率：有了虚拟地址空间，操作系统只需将当前进程正在使用的部分数据或指令载入物理内存。
- 简化内存管理：每个进程有一个一致且私有的虚拟地址空间，程序员无需和真正的物理内存打交道，而是借助虚拟内存访问物理内存，简化内存管理。
- 多个进程共享物理内存：进程运行时会加载许多操作系统的动态库，有的库被多个进程加载，但在内存中只会加载一次，这部分称为共享内存。
- 提高内存安全性：控制进程对物理内存的访问，隔离不同进程的访问权限，从而提升安全性。
- 提供更大可用的内存空间：让程序拥有超过物理内存大小的可用内存空间。当内存不够时，可以利用磁盘空间，将物理内存页保存到磁盘，数据或代码会根据需要在物理内存和磁盘之间移动。

### 没有虚拟内存的问题举例

- 用户可以访问任意物理内存，从而可能访问到操作系统运行所必需的内存，造成操作系统奔溃。
- 多个程序运行容易崩溃，不同程序之间不再有虚拟内存隔离存储空间，一个程序可以操作另一个程序的内存。
- ...

### 虚拟地址和物理地址

虚拟地址：程序中访问的地址，如C语言中指针存储的地址。
物理地址：物理内存的地址，存在于地址寄存器的地址。

操作系统通过CPU中的MMU(Memory Management Unit，内存管理单元)将虚拟地址转换为物理地址，称为地址翻译、地址转换(Address Translation)。
通过MMU将虚拟地址转换为物理地址后，物理地址通过总线传到物理内存设备，进而完成物理内存的读写请求。

- 虚拟地址空间：虚拟地址的集合，即虚拟内存的范围。每个进程有一个一致且私有的虚拟地址空间。
- 物理地址空间：物理地址的集合，即物理内存的范围。

## 三、分段机制

### 段表和地址翻译过程

段表(Segment Table)存储分段机制下虚拟地址和物理地址的映射关系

段虚拟地址构成：
- 段号：标识虚拟地址属于哪一个段
- 段内偏移量：该虚拟地址相对于该段起始地址的偏移量

段地址翻译过程：
- MMU从虚拟地址提取出该地址的段号
- 通过段号从该应用程序的段表中查找对应的段表项
- 从段表项中找到该段的起始物理地址加上段内偏移量即为对应的物理地址

### 段表项一定存在吗？最终得到的物理地址的物理内存一定存在吗？

不一定，段表项可能不存在
- 段表项被删除：软件错误、软件恶意行为可能导致段表项被删除
- 段表项还未创建：系统内存不足或者无法分配到连续的物理内存

### 分段机制容易导致外部内存碎片的原因

分段机制下段与段之间可能存在空隙，这些空隙又因为太小无法分配给其它应用程序导致产生外部内存碎片

## 四、分页机制

分页机制将物理内存划分为连续等长的物理页，将虚拟内存也划分为连续等长的虚拟页，任意虚拟页可以与任意物理页建立映射关系。
分页机制可以为一个应用程序分配离散的物理空间，有效减少了外部内存碎片的问题。

### 页表和地址翻译过程

页表(Page Table)存储页虚拟地址和物理地址之间的映射关系。

页虚拟地址：
- 页号：通过虚拟页号可以查找对应的物理页号
- 页内偏移量：物理页起始地址 + 页内偏移量 = 物理内存地址

页地址翻译过程：
- MMU从虚拟地址中提取出该地址的虚拟页号
- 通过虚拟页号从应用程序中的页表中取出对应的物理页号
- 用该物理页号对应的物理页起始地址加上虚拟地址中的页偏移量得到最终的物理地址

### 通过虚拟页号一定要找到对应的物理页号吗？找到物理页号后最终的物理地址后对应的物理页一定存在吗？

不一定，可能发生页缺失。
物理内存中不存在对应的物理页或者物理内存中有对应的物理页但虚拟页还未和物理页建立映射。

### 多级页表

多级页表的引入是利用局部性原理实现以时间换空间的效果。32位系统一般使用二级页表，64位系统一般使用四级页表。

考虑32位寻址系统，虚拟地址空间为2^32(4G)，假设一个页表大小为4KB，则存储的页表地址数为2^20，一个地址占据4B，全部页表地址占据的大小为4M。若为单级页表，应用程序页表占据的空间就有4M，占据过大的存储空间。

实际应用程序使用的地址空间只占据整个页表的一小部分，考虑将地址划分为2^10个子表，再引入一张表存储子表的地址，构成一个二级页表。假设程序只使用其中两个子表的存储空间，则应用程序只需加载一级页表和两张子表即可，占据空间为12KB，从而节省空间占用。

### TLB和使用TLB的地址翻译过程

转址旁路缓存(Translation Lookaside Buffer, TLB, 也称为快表)是属于MMU内部的一个单元，本质上是一个高速缓存，存储虚拟页号到物理页号的映射关系，目的是加快虚拟地址到物理地址的翻译速度。

翻译过程：
- 使用虚拟地址的虚拟页号从TLB中查找物理页号
- 如果找到对应物理页号，称为TLB命中(TLB hit)，则直接得到对应物理地址
- 如果未找到，称为TLB未命中(TLB miss)，则查询主存中的页表，同时将页表中的该映射项添加到TLB中
- 当TLB已满且需要添加新的页表项时，就按照一定的淘汰策略淘汰掉快表中的一个项

当TLB命中时只需访问一次主存，为命中时需要访问两次主存。由于频繁访问的内存只是其中一小部分，TLB的命中率往往非常高。

### 换页机制与页缺失

当物理内存不够时，操作系统会将一部分物理页的内容存储到磁盘中，等到需要使用的时候再将它们读取到物理内存中。

页缺失：指当前软件试图访问已存在于虚拟地址空间但未被加载在物理内存的一个分页时，由MMU所发出的中断。
- 硬性页缺失(Hard Page Fault)：物理内存中没有对应的物理页。Page Fault Handler会指示CPU从已打开的磁盘文件中读取相应的内容到物理内存，交给MMU建立虚拟页和物理页的映射关系。
- 软性页缺失(Soft Page Fault): 物理内存有对应的物理页，但虚拟页还未和物理页建立映射。Page Fault Handler会指示MMU建立相应的虚拟页和物理页之间的映射关系。

### 页面置换算法

当发生硬性页缺失且没有空闲物理页可用时，操作系统必须将物理内存中的一个物理页淘汰出去，淘汰的规则称为页面置换算法。好的页面置换算法应当减少页缺失出现的次数。

- 最佳页面置换算法(OPT, Optimal)：优先选择以后用不使用或者最长时间内不访问的物理页。无法实现，理论上最优的算法，用于比较其它算法性能。
- 先进先出页面置换算法(FIFO, First In First Out): 选择最先进入内存的页面进行淘汰，性能较差。
- 最久未使用页面置换算法(LRU, Least Recently Used): 选择距离上一次访问时间最久的页面进行淘汰。
- 最少使用页面置换算法(LFU, Least Frequently Used): 选择之前访问次数最少的页面进行淘汰。
- 时钟页面置换算法(Clock): 选择最近未被使用的页面进行淘汰。

LRU算法是实际使用较多的算法，也被认为是最接近OPT的页面置换算法。但在实际应用中会对算法进行一定的改进。

### FIFO页面置换算法性能差的原因?

- 经常访问或者长期存在的页面会被频繁调入调出：较早进入的页面往往是需要经常访问的或需要长期存在的页。
- 存在Belady现象：被置换的页面并不是进程不会访问的，有时会出现分配的页数增多但缺页率反倒提高的现象。这是因为FIFO算法只考虑了页面进入内存的顺序，而没有考虑页面访问的频率和紧迫性。




