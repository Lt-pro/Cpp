# C3变量与常量  

## C++变量类型  

**定义**: 变量其实只不过是程序可操作的存储区的名称。  

**特点**:  

- 每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。

- 变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。
  
**变量类型**:  

- 基本： int, float, double, char, bool, void , wchar_t  

- 高级：枚举、指针、数组、引用、数据结构、类等等  

## C++变量定义与初始化  

**定义**: `type variable_list;`  

**示例**:  

```C++
int    i, j, k;
char   c, ch;
float  f, salary;
double d;
```

**定义加初始化**:  `type variable_name = value;`  

**示例**:  

```C++
extern int d = 3, f = 5;    // d 和 f 的声明 
int d = 3, f = 5;           // 定义并初始化 d 和 f
byte z = 22;                // 定义并初始化 z
char x = 'x';               // 变量 x 的值为 'x'
```  

## C++变量声明  

- 向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译  

- 在 C++ 程序中可以多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。  

- 可以使用extern关键字进行声明  

**头文件与定义**：  

- 变量的定义不能放在头文件中，否则头文件被其它文件包含发生多次定义  
- 有三个例外：const修饰的常量、类定义、inline函数

**注释1： extern关键字?**  

extern 关键字声明在变量和函数之前的说明。

1. 作用在变量之前

    变量只允许定义一次，但可以在多个文件中声明。  

    ```C++
    Test.cpp 中：
    int s32Val = 0;     // 定义一个变量 s32Val，并赋初值为 0
    Test1.cpp 中：

    extern int s32Val;  // 声明变量 s32Val，它在 Test.cpp 中被定义，此处不可赋值
    Test2.cpp 中：

    extern int s32Val;  // 声明变量 s32Val,它在 Test.cpp 中被定义，此处不可赋值
    ```

2. 作用在函数之前

    ```C++
    Test.h：
    extern void Fun();   // 函数声明，extern 用于标识次函数为外部可调用函数
    Test.cpp：

    void Fun();  // 函数定义
    ```

**注释2: 声明与定义的关系?**  

定义包含了声明，但是声明不包含定义，如

```C++
int a = 0;     //定义并声明了变量 a
extern int a;  //只是声明了有一个变量 a 存在，具体 a 在哪定义的，需要编译器编译的时候去找。
```

函数也是类似，定义的时候同时声明。但如果只是声明，编译器只知道有这么个函数，具体函数怎么定义的要编译器去找。

```C++
void fun1();  //函数声明

void fun1(){  //函数定义
    cout<<"fun1"<<endl;
}
```

**注释3: 函数声明?**  

C/C++ 编译 cpp 文件是从上往下编译，所以 main 函数里面调用其他函数时，如果其他函数在 main 函数的下面，则要在 main 函数上面先声明这个函数。

或者把 main 函数放在最下面，这个不仅限于 main 函数，其他函数的调用都是如此。被调用的函数要在调用的函数之前声明。  

## C++常量  

- 常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。

- 常量的值在定义后不能进行修改。  

**定义常量**:  

- #define identifier value
- const type variable = value;  

**注释1：const关键字?**  

const是constant的简写，只要一个变量前面用const来修饰，就意味着该变量里的数据可以被访问，不能被修改。也就是说const意味着只读（readonly）。

规则：const离谁近，谁就不能被修改；

const修饰一个变量，一定要给这个变量初始化值，若不初始化，后面就无法初始化。

本质：const在谁后面谁就不可以修改，const在最前面则将其后移一位，二者等效。  

**注释2： const char*, char const*的区别?**

Bjarne 在他的 The C++ Programming Language 里面给出过一个助记的方法： 把一个声明从右向左读。

```C++
char  * const cp; ( * 读成 pointer to ) 
cp is a const pointer to char 

const char * p; 
p is a pointer to const char; 

char const * p;
```

**注释3: ?**  

- 类型和安全检查不同

    宏定义是字符替换，没有数据类型的区别，同时这种替换没有类型安全检查，可能产生边际效应等错误；

    const常量是常量的声明，有类型区别，需要在编译阶段进行类型检查

- 编译器处理不同

    宏定义是一个"编译时"概念，在预处理阶段展开，不能对宏定义进行调试，生命周期结束与编译时期；

    const常量是一个"运行时"概念，在程序运行使用，类似于一个只读行数据

- 存储方式不同

    宏定义是直接替换，不会分配内存，存储于程序的代码段中；

    const常量需要进行内存分配，存储于程序的数据段中

- 定义域不同

    ```C++  
    void f1 ()
    {
        #define N 12
        const int n 12;
    }
    void f2 ()
    {
        cout<<N <<endl; //正确，N已经定义过，不受定义域限制
        cout<<n <<endl; //错误，n定义域只在f1函数中
    }
    ```  

- 定义后能否取消

    宏定义可以通过#undef来使之前的宏定义失效

    const常量定义后将在定义域内永久有效

    ```C++
    void f1()
    {
    #define N 12
    const int n = 12;

    #undef N //取消宏定义后，即使在f1函数中，N也无效了
    #define N 21//取消后可以重新定义
    }
    ```  

- 是否可以做函数参数

    宏定义不能作为参数传递给函数

    const常量可以在函数的参数列表中出现  

**类型限定符**：类型限定符提供了变量的额外信息，用于在定义变量或函数时改变它们的默认行为的关键字。  

## 变量作用域  

作用域决定了变量的访问范围和生命周期  

**变量分类**：  

- 在函数或一个代码块内部声明的变量，称为局部变量。

- 在函数参数的定义中声明的变量，称为形式参数。

- 在所有函数外部声明的变量，称为全局变量。  

**作用域划分**:  

- 局部作用域：在函数内部声明的变量具有局部作用域，它们只能在函数内部访问。局部变量在函数每次被调用时被创建，在函数执行完后被销毁。

- 全局作用域：在所有函数和代码块之外声明的变量具有全局作用域，它们可以被程序中的任何函数访问。全局变量在程序开始时被创建，在程序结束时被销毁。

- 块作用域：在代码块内部声明的变量具有块作用域，它们只能在代码块内部访问。块作用域变量在代码块每次被执行时被创建，在代码块执行完后被销毁。

- 类作用域：在类内部声明的变量具有类作用域，它们可以被类的所有成员函数访问。类作用域变量的生命周期与类的生命周期相同。

内部作用域中声明的变量与外部作用域中的变量同名，则内部作用域中的变量将覆盖外部作用域中的变量。  

**局部变量和全局变量的初始化**:  

当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值：

|   数据类型   |   初始化默认值    |
|:-----------:|:-----------------:|
|int          |      0         |
|char         |         '\0'      |
|float        |         0         |
|double       |  0             |
|pointer      |     NULL          |
正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果。  

示例：  

```C++
#include <iostream>
using namespace std;
 
// 全局变量声明
int g;
 
int main ()
{
  // 局部变量声明
  int a, b;
 
  // 实际初始化
  a = 10;
  b = 20;
  g = a + b;
 
  cout << g;
 
  return 0;
}
```  

```C++  
#include <iostream>

int main() {
    int a = 10;
    {
        int a = 20;  // 块作用域变量
        std::cout << "块变量: " << a << std::endl;
    }
    std::cout << "外部变量: " << a << std::endl;
    return 0;
}
```  

```C++  
#include <iostream>

class MyClass {
public:
    static int class_var;  // 类作用域变量
};

int MyClass::class_var = 30;

int main() {
    std::cout << "类变量: " << MyClass::class_var << std::endl;
    return 0;
}
```  

**注释1: 全局变量可以在局部函数内被重新赋值?**  

```C++
#include <iostream>

using namespace std;

// 全局变量声明
int g = 20;
int fun1(int a,int b){
    g=a+b;
    cout<<"被改变的全局变量为："<<g<<endl;
    return 0;
}

int fun2(){
    cout<<"此时的全局变量为："<<g<<endl;
    return 0;
}

int main(){
    fun2();
    fun1(10,20);
    fun2();
    return 0;
}
```

**注释2: main函数下面的全局变量?**  

若要想让 main 函数也使用全局变量 a，可以用 extern 对全局变量进行声明，就可以合法使用了。

```C++
#include<iostream>
using namespace std;

int main()
{
     extern int a;
     cout<<"a= "<<a<<endl; //合法，输出10
     return 0;
}
int a=10; //全局变量从此处定义
```  

**注释4: C++ 全局变量、局部变量、静态全局变量、静态局部变量的区别?**

C++ 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6 种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。

从作用域看：

全局变量具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。

静态局部变量具有局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。

局部变量也只有局部作用域，它是自动对象（auto），它在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。

静态全局变量也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。

从分配内存空间看：

全局变量，静态局部变量，静态全局变量都在静态存储区分配空间，而局部变量在栈里分配空间。

全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。

 1)、静态变量会被放在程序的静态数据存储区（数据段）(全局可见)中，这样可以在下一次调用的时候还可以保持原来的赋值。这一点是它与堆栈变量和堆变量的区别。
 2)、变量用static告知编译器，自己仅仅在变量的作用范围内可见。这一点是它与全局变量的区别。
从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。应予以注意。

static 全局变量:改变作用范围，不改变存储位置

static 局部变量：改变存储位置，不改变作用范围
