# 指针续

## 一、基础知识

- 定义：指针是一种派生类型，它指向某块内存的地址
- 声明与初始化指针  

    ```C++
    int a = 0;
    int *p = &a;

    cout <<"address of a is "<<p<<endl;
    cout <<"address of a is "<<&a<<endl;

    cout <<"*p = "<<*p<<endl;
    cout <<"a = "<<a<<endl;
    ```

    这里声明了一个整形指针p并将整形变量a的地址初始化p. 注意\*只对最近的一个变量起作用，声明多个指针需使用多个星号.如`int *p1, *p2, p3;`声明了两个整型指针和一个整型变量。*p表示解除引用，它将以p开始读取4个字节数据并将其解释为整型值。

- 获取变量的地址: &a
- 解除引用: *p会获得指针指向内存的值  
- 不同类型的指针占据相同大小的内存。 如`int *p1; double *p2`的p1, p2占据的内存大小是一样的，但指向的内存大小不同
- 指针的危险: 创建指针时，计算机会分配存储地址的内存但不会分配指针指向数据的内存。指针声明时应赋一个明确的值，如NULL, nullptr(C++11)  
- 指针的意义: 普通变量所使用的内存在栈区，是在运行前即分配好的；而指针在运行阶段分配未命名的内存。  
- 指针运算: 指针支持++,--,+,-四种运算。

    ```C++
    double a[5] = {1.0, 2, 3, 4, 5};
    double *p = a;    
    ```

    p指向数组a的首地址, p++不是通常的加一，而是以首地址为起点向右偏移8个字节，偏移量为指针所对应的类型。--,+,-以此类推。
- 指针的指针: 指针的指针指向一个指针的地址  

    ```C++
    int a = 0;
    int *b = &a;
    int **c = &b;

    cout <<"a = "<<a<<endl;
    cout <<"b = "<<b<<endl;
    cout <<"c = "<<*c<<"\t"<<"&b = "&b<<endl;    
    ```

    a是一块整型变量内存，b指向这块内存空间，c指向存储指向a内存的指针b所在的内存空间。\*c是b的地址，即\*c与b等价，\*\*c表示a的取值，\*\*c与*b等价。同理可定义多级指针，并按类似方式访问取值。  

## 二、指针与自由存储空间  

- new与delete  

    ```C++
    double *p = new double;
    *p = 3.14;
    cout <<"*p = "<<*p;

    delete p;
    ```

    这里使用new从堆区分配了一块存储空间，指定其类型为double, 分配的内存大小为8个字节，地址赋给p。在使用完成后，使用delete释放了p所指向的内存空间。

- new []与delete []

    ```C++
    double *p = new double [100];

    for (int i=0;i<100;i++)
    {
        *(p+i) = 2.0 * i;
        cout <<"*(p + i) = "<<*(p + i)<<endl;
    }

    delete [] p;
    ```

    这里使用new []分配了一块指定大小的浮点数数组的存储空间，并返回数组的首地址赋给p, 最后使用delete [] 逐个删除数组的每一个元素。特别地，大小数值不要求为整数或整型常量，即大小可以在运行时指定，这种方式创建的数组称为**动态数组**。应当注意如p++等指针运算会改变指针取值，使用delete时一定要恢复成原来的地址。

- 注意事项

    * new与delete应成对使用，否则会发生内存泄漏  
    * delete只能删除new分配的内存，但对NULL/nullptr也是有效的  
    * 不要删除同一块内存两次  

## 三、指针与数组  

- 数组名是一个指针常量，不可以修改取值。指针是一个变量，取值可变。  
- `a[i]`与`*(a + i)` 等价， 如果p指向一个动态数组, `p[i]`也是合法的。

    ```C++  
    int a[5] = {1, 2, 3, 4, 5};
    int *p = a;

    cout <<"*(a + 1) = "<<*(a + 1)<<endl;
    cout <<"*(p + 1) = "<<*(p + 1)<<endl;

    cout <<"a[i] = "<<a<<endl;
    cout <<"p[i] = "<<p[i]<<endl;
    ```

- 下列等式成立: a = &a[0] = 第一个元素的地址  
- 数组的地址: `&a`返回的不是数组的首地址，而是整个数组的地址，即该地址被解释为大小为5的整型数组，对应的类型为数组的指针。  

    ```C++
    int a[5] = {1, 2, 3, 4, 5};
    int (*p)[5] = &a;
    ```

    \*优先与p结合，p是一个指针，一个数组的指针。\*p与a等价，即*p指向一个数组的首地址，故有`(*p)[i]`与`a[i]`等价
- 指针数组: 一个数组，数组的每个元素是一个某种类型的指针  

    ```C++
    // 用指针数组访问数组  
    int a[5] = {1, 2, 3, 4, 5};
    int *p[5];
    for (int i=0;i<5;i++)
    {
        p[i] = &a[i];
    }
    for (int i=0;i<5;i++)
    {
        cout <<"*(p[i]) = "<<*(p[i])<<endl;
    }

    // 用指针数组访问字符串列表  
    const char *ps = {
        "First",
        "Second",
        "Third",
        "Forth",
        "Fifth"
    };

    for (int i=0;i<5;i++)
    {
        cout << "values of ps["<<i<<"] = "<<ps[i]<<endl;
    }
    ```

## 四、指针与字符串  

- char数组名，char指针，字符串字面量是一个指向所在存储区域首地址的常指针  
- cout打印C字符串: cout接收字符串的首地址逐个字节读取直到遇到`\0`  
- cout打印字符串本身的地址需要对其进行强制类型转换  

    ```C++
    const char *p = "bear";

    cout <<"*p = "<<p<<endl;
    cout <<"the address of p is "<<(int *)p<<endl;
    ```

- C++不保证字符串字面值被唯一存储，使用两个指针指向同一字符串可以  
- 若拷贝字符串的副本，需要额外分配内存

    ```C++
    // 指针数组管理键盘输入的多个字符串  
    //#include <cstring>

    #define MaxSize 50
    #define NUM     10

    char tmp[MaxSize];
    char *ps[NUM];
    char *p=nullptr;

    for (i=0;i<NUM;i++)
    {
        cout <<"Enter a string: ";
        cin.getline(tmp, MaxSize);
        cout <<endl;

        p = new char[strlen(tmp)+1];    //这种方式可以节约储存多个字符串所需的内存
        strcpy(p, tmp);
        ps[i] = p;
    }

    for (i=0;i<NUM;i++)
    {
        cout <<"the value of ps["<<i<<"] = "<<ps[i]<<endl;
        delete ps[i];
    }

    ```

## 五、指针与结构和类型  

- 指针对结构和类型的操作方式相同  
- 创建结构的指针时需要new并指定结构类型，如`Student *p = new Student`
- 可以使用箭头运算符直接使用指针访问成员，如`p->age = 18;`
- 也可以解除引用获取结构实例用点运算符访问成员，如`(*p).age = 18;`  
- 传入形参时，传递结构的指针一般比结构本身节约内存  


## 六、指针与const

- 普通变量地址赋给普通指针，普通变量地址赋给常指针，常量地址赋给常指针是合法的；普通变量地址赋给普通指针是非法的。
- 指向常量的指针

    ```C++
        int a = 1;
        const b = 0;
        const int *p = &a;
        p = &b;
        a = 10;//valid。  *p = 10; invalid.
    ```
    `const int *p`声明了一个指向常量的指针，指针本身指向的地址可变，但无法通过解除引用修改指向地址的数据，赋给常指针的地址可以来自变量或常量。

- 一级间接关系可以将非常指针赋给常指针

    ```C++
        int n = 13;
        int *p1 = &n;
        const int *p2 = p1;     //非常指针赋给常指针
    ```

- 二级间接关系可能引发不安全

    ```C++
        const int n = 13;
        int *p1;
        const int **p2 = &p1;   //指向整型常量的指针的指针，*p2取值可以修改
        *p2 = &n;   //将常量的地址赋给非常指针。bug来自非常指针和常指针都可赋给常指针变量
        *p1 = 10;   //常量n的取值被修改！     
    ```

- 使用const的理由
    + 避免无意间修改数据
    + const可以使函数处理const和非const实参

- 指针常量，指向常量的指针常量

    ```C++
        int a = 13;
        const int b = 10;
        int const *p1 = &a; //指针常量
        const int const *p2 = &b;   //指向常量的指针常量
    ```
    `int const *p1`声明了一个指针常量，指针本身的值不可修改，但可解除引用修改指向的变量；`const int const *p2`指向常量的指针常量既不可修改自身，也不可解除引用修改指向的变量。

- 小节  

    |类型               |指针       |指向的变量         |
    |:-----------------:|:---------:|:----------------:|
    |非常指针           |变量       |变量               |
    |常指针             |变量       |常量               |
    |指针常量           |常量       |变量               |
    |指向常量的指针常量  |常量       |常量               |
    |指向常指针的指针    |变量       |变量               |

    注：指向的变量可以是普通变量也可以是堆内存，其常量变量划分是指是否可以解除引用修改其值  


